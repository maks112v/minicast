<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>MiniCast Player</title>
    <style>
      :root {
        --primary-color: #007bff;
        --background-color: #f8f9fa;
        --text-color: #333;
        --error-color: #dc3545;
        --success-color: #28a745;
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, system-ui, BlinkMacSystemFont, "Segoe UI",
          Roboto, "Helvetica Neue", Arial, sans-serif;
        line-height: 1.6;
        color: var(--text-color);
        background-color: var(--background-color);
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
        touch-action: manipulation;
        padding: 16px;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
      }

      .container {
        max-width: 600px;
        margin: 0 auto;
        width: 100%;
        background: white;
        border-radius: 12px;
        padding: 24px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }

      h1 {
        font-size: 24px;
        font-weight: 600;
        margin-bottom: 16px;
        text-align: center;
      }

      .player-wrapper {
        background: var(--background-color);
        border-radius: 8px;
        padding: 16px;
        margin: 16px 0;
      }

      .controls {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .volume-control {
        width: 100%;
        margin-top: 8px;
      }

      .volume-control input {
        width: 100%;
      }

      .visualizer {
        width: 100%;
        height: 60px;
        background: var(--background-color);
        border-radius: 8px;
        margin-top: 16px;
      }

      .status {
        margin-top: 16px;
        padding: 12px;
        border-radius: 8px;
        background: var(--background-color);
        font-size: 14px;
        text-align: center;
      }

      .error {
        background-color: #fff3f3;
        color: var(--error-color);
        display: none;
        padding: 12px;
        border-radius: 8px;
        margin-top: 16px;
        text-align: center;
      }

      @media (max-width: 480px) {
        body {
          padding: 12px;
        }

        .container {
          padding: 16px;
        }

        h1 {
          font-size: 20px;
        }

        .player-wrapper {
          padding: 12px;
        }
      }

      @media (prefers-color-scheme: dark) {
        :root {
          --background-color: #1a1a1a;
          --text-color: #fff;
        }

        body {
          background-color: #000;
        }

        .container {
          background: #2d2d2d;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>MiniCast Player</h1>
      <div class="player-wrapper">
        <div class="controls">
          <div id="status" class="status">Connecting to stream...</div>
          <canvas id="visualizer" class="visualizer"></canvas>
          <div class="volume-control">
            <input type="range" id="volume" min="0" max="100" value="100" />
          </div>
        </div>
      </div>
      <div id="error" class="error">
        Connection lost. Attempting to reconnect...
      </div>
    </div>
    <script>
      let audioContext;
      let audioSource;
      let gainNode;
      let analyser;
      let ws;
      let reconnectAttempts = 0;
      const maxReconnectAttempts = 5;

      const visualizer = document.getElementById("visualizer");
      const ctx = visualizer.getContext("2d");
      const volumeControl = document.getElementById("volume");
      const statusDiv = document.getElementById("status");
      const errorDiv = document.getElementById("error");

      function showError(message) {
        errorDiv.textContent = message;
        errorDiv.style.display = "block";
        statusDiv.style.display = "none";
      }

      function showStatus(message) {
        statusDiv.textContent = message;
        statusDiv.style.display = "block";
        errorDiv.style.display = "none";
      }

      function setupAudioContext() {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        gainNode = audioContext.createGain();
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 256;

        gainNode.connect(audioContext.destination);
        gainNode.connect(analyser);

        volumeControl.addEventListener("input", (e) => {
          gainNode.gain.value = e.target.value / 100;
        });
      }

      function drawVisualizer() {
        const bufferLength = analyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);
        const width = visualizer.width;
        const height = visualizer.height;
        const barWidth = width / bufferLength;

        function draw() {
          requestAnimationFrame(draw);

          analyser.getByteFrequencyData(dataArray);
          ctx.fillStyle = "#000";
          ctx.fillRect(0, 0, width, height);

          for (let i = 0; i < bufferLength; i++) {
            const barHeight = (dataArray[i] / 255) * height;
            ctx.fillStyle = "hsl(" + (i * 360) / bufferLength + ", 100%, 50%)";
            ctx.fillRect(
              i * barWidth,
              height - barHeight,
              barWidth - 1,
              barHeight
            );
          }
        }

        draw();
      }

      function connectWebSocket() {
        if (ws) {
          ws.close();
        }

        ws = new WebSocket("ws://" + window.location.host + "/ws");

        ws.onopen = () => {
          showStatus("Connected to stream");
          reconnectAttempts = 0;
        };

        ws.onclose = () => {
          if (reconnectAttempts < maxReconnectAttempts) {
            reconnectAttempts++;
            showError("Connection lost. Reconnecting...");
            setTimeout(connectWebSocket, 1000 * Math.min(reconnectAttempts, 3));
          } else {
            showError("Connection lost. Please refresh the page.");
          }
        };

        ws.onmessage = async (event) => {
          try {
            const arrayBuffer = await event.data.arrayBuffer();
            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

            const source = audioContext.createBufferSource();
            source.buffer = audioBuffer;
            source.connect(gainNode);
            source.start(0);
          } catch (error) {
            console.error("Error playing audio:", error);
          }
        };

        ws.onerror = (error) => {
          console.error("WebSocket error:", error);
          showError("Connection error");
        };
      }

      // Initialize audio context and visualizer
      function init() {
        setupAudioContext();

        // Set up visualizer canvas
        visualizer.width = visualizer.clientWidth;
        visualizer.height = visualizer.clientHeight;

        // Start WebSocket connection
        connectWebSocket();

        // Start visualization
        drawVisualizer();
      }

      // Handle window resize
      window.addEventListener("resize", () => {
        visualizer.width = visualizer.clientWidth;
        visualizer.height = visualizer.clientHeight;
      });

      // Start everything when the page loads
      window.addEventListener("load", init);

      // Handle page visibility changes
      document.addEventListener("visibilitychange", () => {
        if (document.visibilityState === "visible") {
          if (ws.readyState !== WebSocket.OPEN) {
            connectWebSocket();
          }
        }
      });

      // Prevent device sleep if possible
      async function preventSleep() {
        try {
          if (navigator.wakeLock) {
            await navigator.wakeLock.request("screen");
          }
        } catch (err) {
          console.log("Wake Lock not supported:", err);
        }
      }

      preventSleep();
    </script>
  </body>
</html>
